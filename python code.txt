#!/usr/bin/env python3
import numpy as np
import matplotlib.pyplot as plt
import os
from typing import Tuple, Dict, List


# ----------------------------------------------------------------------
# Conditions
# ----------------------------------------------------------------------
CONDITION_SUFFIXES: Dict[str, str] = {
   "healthy": "h",
   "moderate": "m",
   "severe": "s",
}


# Stimulus intensities (rod/cone stimulation)
INTENSITIES: List[int] = [10, 20, 30, 40, 50]


# Base pattern for rod/cone-driven traces
FILENAME_PATTERN = "GAN00_trace_{intensity}_{suffix}"
FILE_EXT = ".txt"


# ----------------------------------------------------------------------
# Bipolar stimulation traces
# ----------------------------------------------------------------------
BIPOLAR_FILES: Dict[str, str] = {
   "healthy": "GAN00_trace_healthy(no stim).txt",
   "moderate": "GAN00_trace_severe_R40C70.txt",
   "severe": "GAN00_trace_mild_R10C50.txt",
}


# Corresponds to 50 pA-equivalent
BIPOLAR_INTENSITY = 50.0


# Spike detection threshold (mV)
SPIKE_THRESHOLD = -20.0




# ----------------------------------------------------------------------
# Helper functions
# ----------------------------------------------------------------------
def load_trace(fname: str) -> Tuple[np.ndarray, np.ndarray]:
   """
   Load time (ms) and voltage (mV) from a two-column text file.
   """
   if not os.path.isfile(fname):
       raise FileNotFoundError(f"File not found: {fname}")
   data = np.loadtxt(fname)
   if data.ndim != 2 or data.shape[1] < 2:
       raise ValueError(f"File {fname} must have at least two columns: time, voltage")
   t = data[:, 0]
   v = data[:, 1]
   return t, v




def detect_spikes(time_ms: np.ndarray,
                 voltage_mV: np.ndarray,
                 threshold_mV: float = SPIKE_THRESHOLD) -> Tuple[np.ndarray, float]:


   if len(time_ms) < 2:
       return np.array([]), 0.0


   above = voltage_mV >= threshold_mV
   crossings = np.where((~above[:-1]) & (above[1:]))[0] + 1
   spike_times_ms = time_ms[crossings]


   duration_ms = time_ms[-1] - time_ms[0]
   duration_s = duration_ms / 1000.0 if duration_ms > 0 else 0.0


   firing_rate_hz = len(spike_times_ms) / duration_s if duration_s > 0 else 0.0
   return spike_times_ms, firing_rate_hz




def compute_dynamic_range(intensities: np.ndarray,
                         firing_rates: np.ndarray) -> float:
   """
   Compute 10–90% dynamic range in dB:


     F_min, F_max from firing_rates
     F_10 = F_min + 0.1 * (F_max - F_min)
     F_90 = F_min + 0.9 * (F_max - F_min)
     I_10, I_90 found by linear interpolation along F–I curve
     D = 10 * log10(I_90 / I_10)


   """
   # Sort by intensity
   idx = np.argsort(intensities)
   I = intensities[idx]
   F = firing_rates[idx]


   F_min = F.min()
   F_max = F.max()


   if np.allclose(F_min, F_max):
       raise ValueError("Firing rate is constant; dynamic range undefined.")


   F_10 = F_min + 0.1 * (F_max - F_min)
   F_90 = F_min + 0.9 * (F_max - F_min)


   # Interpolate to get intensities at which F crosses F_10 and F_90
   I_10 = np.interp(F_10, F, I)
   I_90 = np.interp(F_90, F, I)


   if I_10 <= 0 or I_90 <= 0:
       raise ValueError("Interpolated intensities non-positive; cannot compute dB dynamic range.")


   D_dB = 10.0 * np.log10(I_90 / I_10)
   return D_dB




# ----------------------------------------------------------------------
# Main analysis
# ----------------------------------------------------------------------
def main():
   # Results container: condition -> dict with intensities, rates, traces, etc.
   results = {}


   for condition, suffix in CONDITION_SUFFIXES.items():
       intensities = []
       firing_rates = []
       traces = []  # list of (t, v, intensity)


       print(f"\n=== Condition: {condition} ===")


       # Load rod/cone-driven traces for 10–50 pA
       for I in INTENSITIES:
           fname = FILENAME_PATTERN.format(intensity=I, suffix=suffix) + FILE_EXT
           try:
               t, v = load_trace(fname)
           except Exception as e:
               print(f"  Error loading {fname}: {e}")
               continue


           spikes, fr = detect_spikes(t, v, SPIKE_THRESHOLD)


           intensities.append(float(I))
           firing_rates.append(fr)
           traces.append((t, v, I))


           print(f"  {fname}: spikes={len(spikes)}, FR={fr:.2f} Hz")


       if len(intensities) == 0:
           print("  No valid rod/cone files for this condition; skipping.")
           continue


       intensities = np.array(intensities, dtype=float)
       firing_rates = np.array(firing_rates, dtype=float)


       # Try to compute dynamic range
       try:
           D_dB = compute_dynamic_range(intensities, firing_rates)
           print(f"  Dynamic range: {D_dB:.2f} dB")
       except Exception as e:
           D_dB = np.nan
           print(f"  Could not compute dynamic range for {condition}: {e}")


       # Store basic results
       results[condition] = {
           "intensities": intensities,
           "firing_rates": firing_rates,
           "traces": traces,
           "dynamic_range_dB": D_dB,
       }


       # ------------------------------------------------------------------
       # Load bipolar-stimulation trace (50 pA-equivalent) for this condition
       # ------------------------------------------------------------------
       bip_fname = BIPOLAR_FILES.get(condition, None)
       if bip_fname is not None and os.path.isfile(bip_fname):
           try:
               t_bip, v_bip = load_trace(bip_fname)
               spikes_bip, fr_bip = detect_spikes(t_bip, v_bip, SPIKE_THRESHOLD)
               results[condition]["bipolar_trace"] = (t_bip, v_bip)
               results[condition]["bipolar_fr"] = fr_bip
               results[condition]["bipolar_intensity"] = float(BIPOLAR_INTENSITY)
               print(f"  Bipolar file {bip_fname}: spikes={len(spikes_bip)}, "
                     f"FR={fr_bip:.2f} Hz (plotted at I={BIPOLAR_INTENSITY})")
           except Exception as e:
               print(f"  Error loading bipolar file {bip_fname}: {e}")
       else:
           print(f"  No bipolar file found for {condition} "
                 f"({bip_fname}); skipping bipolar point.")


   if not results:
       print("\nNo data loaded for any condition. Check filenames and paths.")
       return


   # ------------------------------------------------------------------
   # Compute Fmax and Fmax ratio vs healthy for each condition; compute bipolar Fmax ratios vs healthy rod/cone Fmax
   # ------------------------------------------------------------------
   if "healthy" in results:
       Fmax_healthy = results["healthy"]["firing_rates"].max()
       print(f"\nReference Fmax (healthy rod/cone): {Fmax_healthy:.2f} Hz")


       for condition, data in results.items():
           # Rod/cone Fmax and ratio
           Fmax = data["firing_rates"].max()
           ratio = Fmax / Fmax_healthy if Fmax_healthy > 0 else np.nan
           data["Fmax"] = Fmax
           data["Fmax_ratio"] = ratio


           print(f"  {condition}: rod/cone Fmax = {Fmax:.2f} Hz, "
                 f"Fmax/Fmax_healthy = {ratio:.2f}")


           # Bipolar FR and ratio vs healthy rod/cone Fmax
           if "bipolar_fr" in data:
               fr_bip = data["bipolar_fr"]
               bip_ratio = fr_bip / Fmax_healthy if Fmax_healthy > 0 else np.nan
               data["bipolar_Fmax_ratio"] = bip_ratio
               print(f"    {condition} bipolar: FR = {fr_bip:.2f} Hz, "
                     f"FR/Fmax_healthy = {bip_ratio:.2f}")
           else:
               data["bipolar_Fmax_ratio"] = np.nan
   else:
       print("\nWarning: no 'healthy' condition found; cannot compute Fmax ratios.")


   # ------------------------------------------------------------------
   # Plot V(t) for each condition (rod/cone-driven traces + bipolar)
   # ------------------------------------------------------------------
   for condition, data in results.items():
       traces = data["traces"]
       if not traces:
           continue


       plt.figure(figsize=(10, 4))
       for t, v, I in traces:
           plt.plot(t, v, label=f"I={I} pA (PR-driven)")
       # Overlay bipolar trace for this condition as well (if present)
       if "bipolar_trace" in data:
           t_bip, v_bip = data["bipolar_trace"]
           plt.plot(t_bip, v_bip, '--', label="bipolar stim")
       plt.xlabel("Time (ms)")
       plt.ylabel("Membrane potential (mV)")
       plt.title(f"Ganglion cell voltage traces – {condition}")
       plt.legend()
       plt.tight_layout()
       plt.show()


   # ------------------------------------------------------------------
   # Plot F–I curves for all conditions together + bipolar points
   # ------------------------------------------------------------------
   plt.figure(figsize=(7, 5))


   for condition, data in results.items():
       I = data["intensities"]
       F = data["firing_rates"]
       if len(I) == 0:
           continue
       idx = np.argsort(I)
       ratio = data.get("Fmax_ratio", np.nan)


       # Plot rod/cone-driven F–I curve
       line, = plt.plot(
           I[idx],
           F[idx],
           marker="o",
           label=(f"{condition} "
                  f"(D={data['dynamic_range_dB']:.2f} dB, "
                  f"Fmax ratio={ratio:.2f})")
       )
       line_color = line.get_color()


       # Overlay bipolar-stimulation point (if available)
       if "bipolar_fr" in data:
           I_bip = data["bipolar_intensity"]
           F_bip = data["bipolar_fr"]
           bip_ratio = data.get("bipolar_Fmax_ratio", np.nan)
           plt.scatter(
               I_bip,
               F_bip,
               marker="x",
               s=80,
               color=line_color,
               label=(f"{condition} bipolar "
                      f"(Fmax ratio={bip_ratio:.2f})")
           )


   plt.xlabel("Stimulus intensity (pA)")
   plt.ylabel("Firing rate (Hz)")
   plt.title("Ganglion cell F–I curves\n(rod/cone vs bipolar stimulation)")
   plt.legend()
   plt.grid(True)
   plt.tight_layout()
   plt.show()




if __name__ == "__main__":
   main()